/**
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Modifications copyright 2021 Datadog, Inc.
 *
 * The original file was part of aws-lambda-nodejs-runtime-interface-client
 * https://github.com/aws/aws-lambda-nodejs-runtime-interface-client/blob/main/src/utils/UserFunction.ts
 *
 * This module defines the functions for loading the user's code as specified
 * in a handler string.
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadSync = exports.load = void 0;
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var errors_js_1 = require("./errors.js");
var module_importer = require("./module_importer");
var FUNCTION_EXPR = /^([^.]*)\.(.*)$/;
var RELATIVE_PATH_SUBSTRING = "..";
/**
 * Break the full handler string into two pieces, the module root and the actual
 * handler string.
 * Given './somepath/something/module.nestedobj.handler' this returns
 * ['./somepath/something', 'module.nestedobj.handler']
 */
function _moduleRootAndHandler(fullHandlerString) {
    var handlerString = path_1.default.basename(fullHandlerString);
    var moduleRoot = fullHandlerString.substring(0, fullHandlerString.indexOf(handlerString));
    return [moduleRoot, handlerString];
}
/**
 * Split the handler string into two pieces: the module name and the path to
 * the handler function.
 */
function _splitHandlerString(handler) {
    var match = handler.match(FUNCTION_EXPR);
    if (!match || match.length != 3) {
        throw new errors_js_1.MalformedHandlerName("Bad handler");
    }
    return [match[1], match[2]]; // [module, function-path]
}
/**
 * Resolve the user's handler function from the module.
 */
function _resolveHandler(object, nestedProperty) {
    return nestedProperty.split(".").reduce(function (nested, key) {
        return nested && nested[key];
    }, object);
}
function _tryRequireFile(file, extension) {
    var path = file + (extension || "");
    return fs_1.default.existsSync(path) ? require(path) : undefined;
}
function _tryAwaitImport(file, extension) {
    return __awaiter(this, void 0, void 0, function () {
        var path;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    path = file + (extension || "");
                    if (!fs_1.default.existsSync(path)) return [3 /*break*/, 2];
                    return [4 /*yield*/, module_importer.import(path)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: return [2 /*return*/];
            }
        });
    });
}
function _hasFolderPackageJsonTypeModule(folder) {
    // Check if package.json exists, return true if type === "module" in package json.
    // If there is no package.json, and there is a node_modules, return false.
    // Check parent folder otherwise, if there is one.
    if (folder.endsWith("/node_modules")) {
        return false;
    }
    var pj = path_1.default.join(folder, "/package.json");
    if (fs_1.default.existsSync(pj)) {
        try {
            var pkg = JSON.parse(fs_1.default.readFileSync(pj, "utf-8"));
            if (pkg) {
                if (pkg.type === "module") {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        catch (e) {
            console.warn("".concat(pj, " cannot be read, it will be ignored for ES module detection purposes."), e);
            return false;
        }
    }
    if (folder === "/") {
        // We have reached root without finding either a package.json or a node_modules.
        return false;
    }
    return _hasFolderPackageJsonTypeModule(path_1.default.resolve(folder, ".."));
}
function _hasPackageJsonTypeModule(file) {
    // File must have a .js extension
    var jsPath = file + ".js";
    return fs_1.default.existsSync(jsPath)
        ? _hasFolderPackageJsonTypeModule(path_1.default.resolve(path_1.default.dirname(jsPath)))
        : false;
}
/**
 * Attempt to load the user's module.
 * Attempts to directly resolve the module relative to the application root,
 * then falls back to the more general require().
 */
function _tryRequire(appRoot, moduleRoot, module) {
    return __awaiter(this, void 0, void 0, function () {
        var lambdaStylePath, extensionless, pjHasModule, loaded_1, loaded, _a, _b, nodeStylePath;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    lambdaStylePath = path_1.default.resolve(appRoot, moduleRoot, module);
                    extensionless = _tryRequireFile(lambdaStylePath);
                    if (extensionless) {
                        return [2 /*return*/, extensionless];
                    }
                    pjHasModule = _hasPackageJsonTypeModule(lambdaStylePath);
                    if (!pjHasModule) {
                        loaded_1 = _tryRequireFile(lambdaStylePath, ".js");
                        if (loaded_1) {
                            return [2 /*return*/, loaded_1];
                        }
                    }
                    _b = pjHasModule;
                    if (!_b) return [3 /*break*/, 2];
                    return [4 /*yield*/, _tryAwaitImport(lambdaStylePath, ".js")];
                case 1:
                    _b = (_c.sent());
                    _c.label = 2;
                case 2:
                    _a = (_b);
                    if (_a) return [3 /*break*/, 4];
                    return [4 /*yield*/, _tryAwaitImport(lambdaStylePath, ".mjs")];
                case 3:
                    _a = (_c.sent());
                    _c.label = 4;
                case 4:
                    loaded = _a ||
                        _tryRequireFile(lambdaStylePath, ".cjs");
                    if (loaded) {
                        return [2 /*return*/, loaded];
                    }
                    nodeStylePath = require.resolve(module, {
                        paths: [appRoot, moduleRoot],
                    });
                    return [2 /*return*/, require(nodeStylePath)];
            }
        });
    });
}
/**
 * Attempt to load the user's module.
 * Attempts to directly resolve the module relative to the application root,
 * then falls back to the more general require().
 */
function _tryRequireSync(appRoot, moduleRoot, module) {
    var lambdaStylePath = path_1.default.resolve(appRoot, moduleRoot, module);
    // Extensionless files are loaded via require.
    var extensionless = _tryRequireFile(lambdaStylePath);
    if (extensionless) {
        return extensionless;
    }
    // If package.json type != module, .js files are loaded via require.
    var pjHasModule = _hasPackageJsonTypeModule(lambdaStylePath);
    if (!pjHasModule) {
        var loaded_2 = _tryRequireFile(lambdaStylePath, ".js");
        if (loaded_2) {
            return loaded_2;
        }
    }
    // If still not loaded, try .js, .mjs, and .cjs in that order.
    // Files ending with .js are loaded as ES modules when the nearest parent package.json
    // file contains a top-level field "type" with a value of "module".
    // https://nodejs.org/api/packages.html#packages_type
    var loaded = _tryRequireFile(lambdaStylePath, ".cjs");
    if (loaded) {
        return loaded;
    }
    // Why not just require(module)?
    // Because require() is relative to __dirname, not process.cwd(). And the
    // runtime implementation is not located in /var/task
    // This won't work (yet) for esModules as import.meta.resolve is still experimental
    // See: https://nodejs.org/api/esm.html#esm_import_meta_resolve_specifier_parent
    var nodeStylePath = require.resolve(module, {
        paths: [appRoot, moduleRoot],
    });
    return require(nodeStylePath);
}
/**
 * Load the user's application or throw a descriptive error.
 * @throws Runtime errors in two cases
 *   1 - UserCodeSyntaxError if there's a syntax error while loading the module
 *   2 - ImportModuleError if the module cannot be found
 */
function _loadUserApp(appRoot, moduleRoot, module) {
    return __awaiter(this, void 0, void 0, function () {
        var e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, _tryRequire(appRoot, moduleRoot, module)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    e_1 = _a.sent();
                    if (e_1 instanceof SyntaxError) {
                        throw new errors_js_1.UserCodeSyntaxError(e_1);
                        // @ts-ignore
                    }
                    else if (e_1.code !== undefined && e_1.code === "MODULE_NOT_FOUND") {
                        // @ts-ignore
                        throw new errors_js_1.ImportModuleError(e_1);
                    }
                    else {
                        throw e_1;
                    }
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function _loadUserAppSync(appRoot, moduleRoot, module) {
    try {
        return _tryRequireSync(appRoot, moduleRoot, module);
    }
    catch (e) {
        if (e instanceof SyntaxError) {
            throw new errors_js_1.UserCodeSyntaxError(e);
            // @ts-ignore
        }
        else if (e.code !== undefined && e.code === "MODULE_NOT_FOUND") {
            // @ts-ignore
            throw new errors_js_1.ImportModuleError(e);
        }
        else {
            throw e;
        }
    }
}
function _throwIfInvalidHandler(fullHandlerString) {
    if (fullHandlerString.includes(RELATIVE_PATH_SUBSTRING)) {
        throw new errors_js_1.MalformedHandlerName("'".concat(fullHandlerString, "' is not a valid handler name.Use absolute paths when specifying root directories in handler names."));
    }
}
/**
 * Load the user's function with the approot and the handler string.
 * @param appRoot {string}
 *   The path to the application root.
 * @param handlerString {string}
 *   The user-provided handler function in the form 'module.function'.
 * @return userFuction {function}
 *   The user's handler function. This function will be passed the event body,
 *   the context object, and the callback function.
 * @throws In five cases:-
 *   1 - if the handler string is incorrectly formatted an error is thrown
 *   2 - if the module referenced by the handler cannot be loaded
 *   3 - if the function in the handler does not exist in the module
 *   4 - if a property with the same name, but isn't a function, exists on the
 *       module
 *   5 - the handler includes illegal character sequences (like relative paths
 *       for traversing up the filesystem '..')
 *   Errors for scenarios known by the runtime, will be wrapped by Runtime.* errors.
 */
var load = function (appRoot, fullHandlerString) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, moduleRoot, moduleAndHandler, _b, module, handlerPath, userApp, handlerFunc;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _throwIfInvalidHandler(fullHandlerString);
                    _a = __read(_moduleRootAndHandler(fullHandlerString), 2), moduleRoot = _a[0], moduleAndHandler = _a[1];
                    _b = __read(_splitHandlerString(moduleAndHandler), 2), module = _b[0], handlerPath = _b[1];
                    return [4 /*yield*/, _loadUserApp(appRoot, moduleRoot, module)];
                case 1:
                    userApp = _c.sent();
                    handlerFunc = _resolveHandler(userApp, handlerPath);
                    if (!handlerFunc) {
                        throw new errors_js_1.HandlerNotFound("".concat(fullHandlerString, " is undefined or not exported"));
                    }
                    if (typeof handlerFunc !== "function") {
                        throw new errors_js_1.HandlerNotFound("".concat(fullHandlerString, " is not a function"));
                    }
                    return [2 /*return*/, handlerFunc];
            }
        });
    });
};
exports.load = load;
/**
 * Load the user's function with the approot and the handler string.
 * @param appRoot {string}
 *   The path to the application root.
 * @param handlerString {string}
 *   The user-provided handler function in the form 'module.function'.
 * @return userFuction {function}
 *   The user's handler function. This function will be passed the event body,
 *   the context object, and the callback function.
 * @throws In five cases:-
 *   1 - if the handler string is incorrectly formatted an error is thrown
 *   2 - if the module referenced by the handler cannot be loaded
 *   3 - if the function in the handler does not exist in the module
 *   4 - if a property with the same name, but isn't a function, exists on the
 *       module
 *   5 - the handler includes illegal character sequences (like relative paths
 *       for traversing up the filesystem '..')
 *   Errors for scenarios known by the runtime, will be wrapped by Runtime.* errors.
 */
var loadSync = function (appRoot, fullHandlerString) {
    _throwIfInvalidHandler(fullHandlerString);
    var _a = __read(_moduleRootAndHandler(fullHandlerString), 2), moduleRoot = _a[0], moduleAndHandler = _a[1];
    var _b = __read(_splitHandlerString(moduleAndHandler), 2), module = _b[0], handlerPath = _b[1];
    var userApp = _loadUserAppSync(appRoot, moduleRoot, module);
    var handlerFunc = _resolveHandler(userApp, handlerPath);
    if (!handlerFunc) {
        throw new errors_js_1.HandlerNotFound("".concat(fullHandlerString, " is undefined or not exported"));
    }
    if (typeof handlerFunc !== "function") {
        throw new errors_js_1.HandlerNotFound("".concat(fullHandlerString, " is not a function"));
    }
    return handlerFunc;
};
exports.loadSync = loadSync;
//# sourceMappingURL=user-function.js.map